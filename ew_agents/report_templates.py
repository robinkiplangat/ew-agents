"""
ElectionWatch Agent Report Templates

This module contains standardized JSON templates that agents can use to structure
their analysis reports consistently.
"""

import json
from datetime import datetime
from typing import Dict, Any, List, Optional

class ElectionWatchReportTemplate:
    """
    Standardized templates for ElectionWatch agent reports
    """
    
    @staticmethod
    def get_analysis_template() -> dict:
        """
        Return a unified JSON template for structuring election monitoring analysis reports.
        
        The template supports various report types and analysis depths, providing standardized fields for metadata, narrative classification, actors, lexicon terms, risk assessment, recommendations, and analysis insights.
        Returns:
            dict: The unified analysis template with default values for all required fields.
        """
        return {
            "report_metadata": {
                "report_id": "AutoGeneratedReport",
                "analysis_timestamp": datetime.now().isoformat(),
                "report_type": "analysis",
                "content_type": "",  # text, image, video, csv, multimedia
                "analysis_depth": "standard"  # quick, standard, comprehensive
            },
            "narrative_classification": {
                "theme": "",
                "threat_level": "",
                "details": "",
                "confidence_score": 0.0,
                "alternative_themes": [],
                "threat_indicators": []
            },
            "actors": [
                {
                    "name": "",
                    "affiliation": "",
                    "role": "",
                    "influence_level": "",
                    "verification_status": "",
                    "social_metrics": {}
                }
            ],
            "lexicon_terms": [
                {
                    "term": "",
                    "category": "",
                    "context": "",
                    "confidence_score": 0.0,
                    "language": "en",
                    "severity": "",
                    "definition": ""
                }
            ],
            "risk_level": "",
            "date_analyzed": datetime.now().isoformat(),
            "recommendations": [],
            "analysis_insights": {
                "content_statistics": {
                    "word_count": 0,
                    "character_count": 0,
                    "language_detected": "en"
                },
                "threat_assessment": {
                    "overall_risk_score": 0.0,
                    "violence_potential": "",
                    "electoral_impact": "",
                    "social_cohesion_threat": "",
                    "urgency_level": ""
                }
                ,
                "processing_metadata": {
                    "agents_utilized": [],
                    "analysis_duration": 0.0,
                    "confidence_level": "medium",
                    "data_sources": []
                }
            }
        }
    
    @staticmethod
    def create_analysis_report(content_type: str = "text", 
                             analysis_depth: str = "standard", 
                             **kwargs) -> dict:
        """
                             Generate a populated election analysis report based on the unified template.
                             
                             Parameters:
                                 content_type (str): The type of content analyzed (e.g., text, image, video, csv, multimedia).
                                 analysis_depth (str): The depth of analysis to perform (quick, standard, or comprehensive).
                                 **kwargs: Additional data to populate specific fields within the report template.
                             
                             Returns:
                                 dict: The completed analysis report with metadata, classification, actors, lexicon terms, risk assessment, recommendations, and insights.
                             """
        template = ElectionWatchReportTemplate.get_analysis_template()
        
        # Set content type and analysis depth
        template["report_metadata"]["content_type"] = content_type
        template["report_metadata"]["analysis_depth"] = analysis_depth
        
        # Update template with provided data
        def update_nested_dict(d: Dict, updates: Dict):
            """
            Recursively updates a nested dictionary with values from another dictionary.
            
            Parameters:
                d (dict): The dictionary to be updated.
                updates (dict): The dictionary containing updates to apply to `d`.
            """
            for key, value in updates.items():
                if key in d:
                    if isinstance(d[key], dict) and isinstance(value, dict):
                        update_nested_dict(d[key], value)
                    else:
                        d[key] = value
        
        update_nested_dict(template, kwargs)
        return template
    
    @staticmethod
    def validate_analysis_report(report: dict) -> dict:
        """
        Validate whether a report dictionary matches the unified analysis template structure.
        
        Parameters:
            report (dict): The report data to validate.
        
        Returns:
            dict: Validation results including validity, missing and extra keys, and a compliance score. If validation fails, returns error details and a compliance score of 0.0.
        """
        try:
            template = ElectionWatchReportTemplate.get_analysis_template()
            required_keys = set(template.keys())
            report_keys = set(report.keys())
            
            missing_keys = required_keys - report_keys
            extra_keys = report_keys - required_keys
            
            return {
                "valid": len(missing_keys) == 0,
                "missing_keys": list(missing_keys),
                "extra_keys": list(extra_keys),
                "compliance_score": len(report_keys & required_keys) / len(required_keys)
            }
        except Exception as e:
            return {
                "valid": False,
                "error": str(e),
                "compliance_score": 0.0
            }
    
    @staticmethod
    def export_analysis_report(report_data: dict) -> dict:
        """
        Prepares an analysis report for export by generating a JSON-compatible dictionary with metadata.
        
        Returns:
            dict: Contains export status, generated filename, report data, export timestamp, and a message. If an error occurs, includes error details and a failure status.
        """
        try:
            # Generate filename automatically
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"electionwatch_report_{timestamp}.json"
            
            # For now, return the data instead of writing to file (API context)
            return {
                "success": True,
                "filename": filename,
                "report_data": report_data,
                "export_timestamp": datetime.now().isoformat(),
                "message": f"Report prepared for export as {filename}"
            }
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "timestamp": datetime.now().isoformat()
            }

# Utility functions for backwards compatibility and easy access
def get_analysis_template(content_type: str = "text", analysis_depth: str = "comprehensive") -> dict:
    """
    Retrieve the unified election analysis report template.
    
    Parameters:
        content_type (str): Type of content to be analyzed (e.g., "text", "image", "video", "csv", "multimedia").
        analysis_depth (str): Level of analysis detail ("quick", "standard", or "comprehensive").
    
    Returns:
        dict: A dictionary representing the standardized analysis report template.
    """
    return ElectionWatchReportTemplate.get_analysis_template()

def create_analysis_report(content_type: str = "text", analysis_depth: str = "standard", **kwargs) -> dict:
    """
    Generate a populated election analysis report using the unified template.
    
    Parameters:
        content_type (str): The type of content analyzed (e.g., "text", "image", "video", "csv", "multimedia").
        analysis_depth (str): The depth of analysis ("quick", "standard", or "comprehensive").
        **kwargs: Additional fields to populate or override in the report.
    
    Returns:
        dict: The completed analysis report structured according to the unified template.
    """
    return ElectionWatchReportTemplate.create_analysis_report(content_type, analysis_depth, **kwargs)

def export_analysis_report(report_data: dict) -> dict:
    """
    Prepares the analysis report data for export as a JSON-compatible dictionary.
    
    Parameters:
        report_data (dict): The populated analysis report to be exported.
    
    Returns:
        dict: Contains export status, generated filename, report data, export timestamp, and a message. If export fails, includes error details.
    """
    return ElectionWatchReportTemplate.export_analysis_report(report_data)

# Template instruction for agents
AGENT_TEMPLATE_INSTRUCTION = """
When generating analysis reports, use the unified ElectionWatchReportTemplate.get_analysis_template() 
to ensure consistent structure across all analysis types.

The template automatically adapts to different content types:
- Text analysis (social media posts, articles)
- Image analysis (screenshots, memes, infographics) 
- Video analysis (deepfakes, propaganda videos)
- CSV analysis (datasets, social media exports)
- Multimedia analysis (combined content types)

Always populate the following key fields:
- report_metadata (with content_type and analysis_depth)
- narrative_classification (with theme, threat_level, details)
- actors (with name, role, affiliation)
- lexicon_terms (with detected terms and categories)
- risk_level (overall assessment)
- recommendations (actionable items)
- analysis_insights (detailed technical information)

Use create_analysis_report() method to populate templates with your analysis data.
Export final reports using export_analysis_report() for persistent storage.
"""

# Create FunctionTool instances for coordinator use
try:
    from google.adk.tools import FunctionTool
    
    get_analysis_template_tool = FunctionTool(
        func=get_analysis_template
    )
    
    export_analysis_report_tool = FunctionTool(
        func=export_analysis_report
    )
    
    # Aliases for agent.py compatibility
    generate_analysis_template_tool = get_analysis_template_tool
    generate_report_template_tool = export_analysis_report_tool
    
except ImportError:
    # Fallback for when google.adk.tools is not available
    get_analysis_template_tool = None
    export_analysis_report_tool = None
    generate_analysis_template_tool = None
    generate_report_template_tool = None 